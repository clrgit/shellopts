#!/usr/bin/env ruby

$LOAD_PATH.unshift "#{Dir.getwd}/lib"

require 'shellopts'

spec = %(
  cmd1!
    This is some text 1

    cmd11!
      This is some more text 11

    cmd12!
      This is some more text 12
      
      cmd121!
        Even more text 121

  cmd2!
    This is some text 2
  cmd2.cmd21!
    This is some text 221
  cmd2.cmd22.cmd221!
    This is some text 222221
)


spec = %(
  cmd1!
    cmd2!

  cmd1.cmd2!
)

spec = %(
  -a -b @ -a and -b brief
  -c @ -c brief
    Describes -a, -b, and -c

  -d 
    @ -d brief
    Describes -d

  cmd1! -e @ cmd1 brief
  cmd1_alias! --special-option
    @default cmd1 brief

    Command description

    cmd11! -f
      Some text

      @ cmd11 brief

      Some more text

      -g -h #@ grief
      -i
        Describes -g, -h, and -i

      -j=FILE
        Describes -j

  cmd2! 
    Finally
)

spec = %(
  cmd1!
    --opt1

    cmd11! --opt11

    cmd12!

  cmd1.cmd4!
    --opt4
      Now, is this legal: 'cmd1 --opt1 cmd4 --opt4' ?

  cmd2!

  cmd1.cmd5!
    --opt5
      And are both of these legal: 'cmd1 cmd5 --opt5' and 'cmd2 --opt5

)

spec = %(
  --opt0

  --opt1

  cmd0! --cmd0-opt
  cmd00! --cmd00-opt
    
    --opt2

  cmd1! --opt3 --opt4

    --opt5

  cmd2! --opt6
)

spec = %(
  --opt1
  --opt2
  --opt3,opt4

  cmd1! --opt5
    --opt6

    --opt7

)

# TODO
#spec = %(
# cmd1! ++ NAME:EFILE
#)

#spec = %(
# cmd1! ++ EFILE NAME
#
# cmd2! ++ VALUE:#
#)

#spec = %(
# cmd1! ++ NAME:EFILE
#)

#spec = %(
# cmd1! ++ EFILE NAME
#
# cmd2! ++ VALUE:#
#)

#spec = %(
# cmd! -- ARG
#)
#
#spec = %(
# -a
# -b
#)
#
spec = %(
  --opt=EFILE
)

spec = %(
  ++ ARG0

  cmd0!
  cmd1! ++ ARG1
  cmd2! ++ ARG2
    ++ ARG3 # <- make this act as default
)

#spec = %(
# ++ ARG
#)

spec = %(
  -A,B
  -a -b @ -a and -b brief
  -c @ -c brief
    Describes -a, -b, and -c

  -d 
    @ -d brief
    Describes -d

  cmd1! -e @ cmd1 brief
  cmd1_alias! --special-option
    @default cmd1 brief

    Command description

    cmd11! -f
      Some text

      @ cmd11 brief

      Some more text

      -g -h #@ grief
      -i
        Describes -g, -h, and -i

      -j=FILE
        Describes -j

  cmd2! ++ ARG
    Finally
)

spec = %(
  -a @ this brief

  -b 
  
  cmd1! 
    -c

    -d 
    
  cmd2! 
    -e 

    -f 
  
  cmd2.cmd3! 
    -g
)

sh = ShellOpts::ShellOpts.new(
#   version: "-V,VERSION:1.2.3", 
    version: false, 
    quiet: "-Q,QUIET", verbose: true, debug: true,
    exception: true) 
sh.compile(spec)
sh.grammar.dump(&:debug)
exit


spec_singleline = "-a -b cmd1! -c -d cmd2! -e -f cmd2.cmd3! -g"
#spec_singleline = "-a,b"

def compile(s)
  multiline = !s.index("\n").nil?
  ShellOpts::Parser.parse(ShellOpts::Lexer.lex("main", s), multiline: multiline)
end

compile(spec).dump(format: :debug)
#compile(spec_singleline).dump(format: :debug)

g = compile(spec_singleline)
g.filter(ShellOpts::Ast::Option) { |opt|
  p opt
  p opt.name
  p opt.names
  p opt.ident
  p opt.idents
}



exit

lexer = ShellOpts::Lexer.new("main", spec)
tokens = lexer.lex

#puts "Tokens"
#indent { tokens.each(&:dump) }
#puts
#exit

sl = !spec.index("\n").nil?
parser = ShellOpts::Parser.new(tokens, sl: sl)
#ast = parser.parse
ast = parser.parse

puts "Ast#dump"
#indent { ast.dump(format: :rspec) }
indent { ast.dump(format: :debug) }
puts
exit

analyzer = ShellOpts::Analyzer.new(ast)
grammar, doc = analyzer.analyze

puts "Grammar#dump"
indent { grammar.dump }
puts
exit




#puts "Grammar#dump(:rspec)"
#ShellOpts::Grammar::Format.set :rspec
#indent { grammar.dump }
#puts
#exit


#
#spec.dump
#puts
#exit

#analyzer = ShellOpts::Analyzer.new(spec)
#grammar, doc = analyzer.analyze
#
#puts "Grammar#dump(:debug)"
#indent { grammar.dump }
#puts
#exit

#p grammar.dot(:!)
#p grammar.dot(:cmd1!)
#p grammar.dot(:"cmd1.e")
#
#p grammar.dot(:"cmd1_alias!")
#
#p grammar.dot(:"cmd2!")
#p grammar.dot(:"cmd2[0]")

def compile(s)
  tokens = ShellOpts::Lexer.lex("main", s)
  spec = ShellOpts::Parser.parse(tokens)
  grammar, doc = ShellOpts::Analyzer.analyze(spec)
  grammar
end

spec = %(
  -a

  -b

  cmd1!

  cmd2!
)

args = "-a cmd1"
argv = args.split(" ")

grammar = compile(spec)
interpreter = ShellOpts::Interpreter.new(grammar, argv, exception: true)
interpreter.interpret








#puts "Grammar#dump(:rspec)"
#ShellOpts::Grammar::Format.set :rspec
#indent { grammar.dump }
#puts
#exit

#puts "Grammar#dump(:rspec_option)"
#ShellOpts::Grammar::Format.set :rspec_option
#indent { grammar.dump }
#puts
#exit

#puts "Grammar#dump(:rspec_command)"
#ShellOpts::Grammar::Format.set :rspec_command
#indent { grammar.dump }
#puts
#exit

#puts "Grammar#dump(:rspec_arg)"
#ShellOpts::Grammar::Format.set :rspec_arg
#indent { grammar.dump }
#puts
#exit






__END__

#p grammar.groups.size
#p grammar.subcommands.map(&:ident)
#exit
#indent {
# grammar.groups.each { |group|
#   p group.commands.map(&:ident)
#   indent {
#     p group.subcommands.map(&:ident)
#   }
# }
#}

grp1 = grammar.groups.first
grp2 = grammar.groups.last

p grp1.subcommands
p grp2.subcommands

prg = grammar.commands.first
p prg.subcommands
p prg.subcommands.first.subcommands
p prg.subcommands.last.subcommands
exit

indent { grammar.dump }

exit

puts
program.dump(format: :rspec)
#puts
#program.dump(format: :debug)

__END__


# TODO: Option parsing
#spec = %(
# -f=FILE @ own brief
# -s,str=FILE @ another brief
# -g=FILE -t,txt=FILE @ shared brief
#   shared doc
#)

#spec = %(
# -a 
# 
# -b -c # Shares brief and doc
#
# -d,e # Aliases
#
# -f # Shares doc and brief
# -g
#
# -h -i @subgroup-brief
# -j @option-brief
# -k 
#   @group-brief
#)
  


#SPEC = %(
# NAME
#   Text
#)

SPEC = %(
  SYNOPSIS
    Synopsis
    are on 
    seperate lines

  DESCRIPTION
    Paragraphs
    spans over 
    multiple lines
)

lexer = ShellOpts::Lexer.new("main", SPEC)
tokens = lexer.lex
pp tokens
#puts
parser = ShellOpts::Parser.new(tokens)
program = parser.parse
program.dump(format: :debug)










#puts "--------------------------------"
#puts SPEC
#puts
#program.dump(format: :short)
#puts
#program.dump(format: :rspec)

#puts
#puts ShellOpts::Spec::Node.descendants(this: true)
#ShellOpts::Spec::Node.dump_hierarchy

#ShellOpts::Spec::Formatter.format(program, format: :rspec)
#formatter.format
#program.dump(format: :rspec)
#parser.program.dump2





__END__


opts, args = ShellOpts.process(SPEC, ARGV, version: "--ver", version_number: "1.2.3", help: "-?,help")

verb "Verbose default"
(0..3).each { |i| verb i, "Verbose #{i}" }
mesg "Message"
notice "Notice"
#debug "Debug"


